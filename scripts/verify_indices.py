#!/usr/bin/env python3

import argparse as ap
import pandas as pd
import numpy as np
import csv
from sys import exit
# from Levenshtein import distance
from scipy.spatial.distance import squareform
from itertools import combinations

def get_args():
    parser = ap.ArgumentParser(
        description= 
        """
        Takes a samplesheet generated by Illumina run manager and checks for 
        conflicting indices. Returns a vector of optimal values to use for the 
        --barcode_mismatches argument of bcl2fastq
        """
    )
    parser.add_argument('-i', '--input_file', help='path to samplesheet')
    parser.add_argument('-o', '--output_file', help ='path to write output barcode mistmatch vector')
    args = parser.parse_args()
    return args

def parse_input(samplesheet):
    with open(samplesheet, 'r') as fi:
        reader = csv.reader(fi)
        for row in reader:
            if row and row[0] == '[Data]':
                break
        columns = next(reader)
        data = pd.DataFrame(reader, columns=columns)
    return data

def validate_indices(data):
    indices = data['index'].to_numpy()#.reshape(-1,1)#[:,None]#
    ## Levenshtein
    # distances = [distance(i, j) for (i, j) in combinations(indices, 2)]
    ## Hamming
    distances = [sum(chi != chj for chi,chj in zip(i,j)) for (i, j) in combinations(indices, 2)]
    distances = pd.DataFrame(squareform(distances), columns=indices, index=indices)
    ## Masking diagonal
    distances = distances.mask(np.eye(distances.shape[0], dtype=bool))
    min_edit_distance = distances.min(1)
    allowed_mismatches = []
    ## making it explicit incase this understanding changes
    illumina_formula = lambda x: (2*x) + 1
    for index in indices:
        value = min_edit_distance[index]
        ## Default of 1
        # if value >= illumina_formula(2):
        #     allowed_mismatches.append(2)
        if value >= illumina_formula(1):
            allowed_mismatches.append('1')
        elif value >= illumina_formula(0):
            matching_indices = distances[index][distances[index]<3].index.to_list()
            print('Barcode {} is too close to the following barcode(s): {} and will require 0 allowed mismatches'.format(index, matching_indices))
            allowed_mismatches.append('0')
        else:
            print('ERROR: Barcode {} is present twice in the samplesheet'.format(index))
            exit('Quitting program. Fix the identical barcode issues and rerun.')
            allowed_mismatches.append('NaN')
    return allowed_mismatches, indices

args = get_args()
samplesheet = parse_input(args.input_file)
allowed_mismatches, indices = validate_indices(samplesheet)
#. Final allowed mismatch values:")
with open(args.output_file, 'w') as fo:
    fo.write(min(allowed_mismatches))

print('Samplehseet {} needs barcode-mismatches set to {}'.format(args.input_file, min(allowed_mismatches)))
# print("Index verification complete")
